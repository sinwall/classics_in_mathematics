<html>
<head>
<meta charset="utf-8">
<script>
MathJax = {
    tex: {
        inlineMath: [['$', '$']],
        macros: {
            ol: ["\\overline{#1}", 1]
        }
    },
    svg: {
        fontCache: "global"
    }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script type="importmap">
{
    "imports": {
        "three": "./module-three/src/Three.js",
        "three/addons/": "./module-three/examples/jsm/"
    }
}
</script>
<style>
.boxed {
    /* border: solid; */
    box-shadow: 0 0 0 2px #000 inset;
}
.row {
    position: relative;
}
.col {
    position: relative;
    float:left;
}
.text-col-body{
    height:80%;
    overflow-y: scroll;
}
.text-col-foot{
    height:15%;
    overflow-y: scroll;
}
.unselectable {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}
.multilayer {
    position: relative;
}
.language-layer {
    position: absolute;
}
</style>
</head>

<body>

 <div id="page-title" class="row boxed" style="width: 1200px; text-align: center; font-size: 20pt">
Mathematica Classica per Linguas Figurasque
    <div id="nav-wrapper">
    <button id="button-fig-prev">◁</button>
    <select name="fig" id="select-fig"></select>
    <button id="button-fig-next">▷</button>
    </div>
 </div>

 <div id="page-content" class="row boxed" style="width: 1200px; height:800px;">
  <div id="page-content-col1" class="col boxed" style="width:32%; height:100%;">
    <div id="page-content-col1-title" class="row boxed">
    Column 1
    <select id="select-lang1"></select>
    </div>
    <div id="page-content-col1-body" class="row boxed text-col-body" style="white-space:break-spaces; ">
    Content 1
    </div>
    <div id="page-content-col1-foot" class="row text-col-foot boxed" style="white-space:break-spaces;"></div>
  </div>
  <div id="page-content-col2" class="col boxed" style="width:32%; height:100%;">
    <div id="page-content-col2-title" class="row boxed">
    Column 2
    <select id="select-lang2"></select>
    </div>
    <div id="page-content-col2-body" class="row boxed text-col-body" style="white-space:break-spaces;">
    Content 2
    </div>
    <div id="page-content-col2-foot" class="row text-col-foot boxed" style="white-space:break-spaces;"></div>
  </div>
  <div id="page-content-col3" class="col boxed" style="height:100%;">
    <div id="page-content-col3-title" class="row boxed">
    Column 3
    </div>
    <div id="svg-wrapper" class="row boxed" style="position: relative; width: 400px; height: 400px;">
    </div>
    <div class="boxed">
    Select construction step
     <button id="button-back">◁</button>
     <select name="step" id="select-step">
     </select>
     <button id="button-forward">▷</button>
     <input id="check-original" type="checkbox">original</input>
    </div>
  </div>
 </div>

</body>

</html>
<script type="module">
// import {readFileSync} from 'fs'

async function loadRawTextJson(sourcePath) {
    let result;
    await new Promise(function (resolve, reject) {
        let xhr = new XMLHttpRequest();
        xhr.open("GET", sourcePath)
        xhr.onload = function () {
            if ((xhr.status >= 200) && (xhr.status < 400)) {
                result = JSON.parse(xhr.responseText);
            }
            else {
                ;
                // reject();
            }
            resolve();
        }
        xhr.send();
    })
    return result;
}

function arrangeMultilayerSize(textColumn) {
    let outers = textColumn.querySelectorAll('.multilayer')
    for (let outer of outers) {
        for (let inner of outer.querySelectorAll('.language-layer')) {
            if (Number(outer.style.height.replace('px','')) < inner.offsetHeight) {
                outer.style.height = `${inner.offsetHeight}px`;
            }
        }
    }
}
function insertTextToElement(textColumn, proposition) {
    let innerOuter;
    for (let i=textColumn.childNodes.length; i>0; i--) {
        textColumn.childNodes[0].remove();
    }
    let numParagraph = proposition.ELH.paragraphs.length;
    for (let i=0; i<numParagraph; i++) {
        let outer = document.createElement('div');
        outer.classList.add('multilayer', 'boxed')
        textColumn.appendChild(outer);
        // outer.style = 'position: relative;';
        for (let j=0; j<langList.length; j++) {
            let inner = document.createElement('div');
            inner.classList.add(langList[j], 'language-layer');
            // inner.style = 'position: absolute;';
            inner.innerHTML = proposition[langList[j]].paragraphs[i];
            outer.appendChild(inner);
            // if (Number(outer.style.height.replace('px','')) < inner.offsetHeight) {
            //     outer.style.height = `${inner.offsetHeight}px`;
            // }
        }
    }
    MathJax.typeset();
    arrangeMultilayerSize(textColumn)
}


// async function loadRawText(sourcePath) {
//     let result = {}
//     for (let i=0; i<langList.length; i++) {
//         let lang = langList[i];
//         result[lang] = {loaded: false};
//         await new Promise(function (resolve, reject) {
//             let xhr = new XMLHttpRequest();
//             xhr.open("GET", sourcePath + "_" + lang + ".txt")
//             xhr.onload = function () {
//                 if ((xhr.status >= 200) && (xhr.status < 400)) {
//                     result[lang] = classifyText(xhr.responseText, lang);
//                     result[lang].loaded = true;
//                 }
//                 else {
//                     ;
//                     // reject();
//                 }
//                 resolve();
//             }
//             xhr.send();
//         })
//     }
//     return result;
// }


// function renderText(textBundle, lang) {
//     let result;
//     if (!textBundle.loaded) { return "Text not prepared"}
//     if (lang == "KOM") {
//         result = (
//             "<b>정리.</b> " + textBundle.theorem + "\n\n" 
//             + "<b>증명.</b> " + textBundle.proof + "\n\n" 
//             + "<b>참고.</b> " + textBundle.remark
//         );
//         result += "\n\n";
//         for (let i=0; i<textBundle.footnotes.length; i++) {
//             result += `<sup>${i+textBundle.footnoteIndex+1}</sup> ${textBundle.footnotes[i]}`;
//             if (i<textBundle.footnotes.length-1) {result += "\n";}
//         }
//     }
//     else {
//         result = textBundle.text;
//     }
//     return result
// }

// function classifyText(string, lang=null, footnoteIndex=0) {
//     let result = {footnoteIndex: footnoteIndex};
//     if (lang == "KOM") {
//         string = string.replace("\\\\", "");
//         result.footnotes = []; 
//         string = string.replaceAll(
//             /\\footnote{([^{}]+)}/gs, 
//             function (match, p1, offset, string, groups) {
//                 footnoteIndex++; 
//                 result.footnotes.push(p1);
//                 return `<sup>${footnoteIndex}</sup>`;
//             }
//         )
//         let theorem = [...string.matchAll(/\\begin{theorem}(.+)\\end{theorem}/gs)];
//         result.theorem = theorem[0][1].trim();
//         let proof = [...string.matchAll(/\\begin{proof}(.+)\\end{proof}/gs)];
//         result.proof = proof[0][1].trim();
//         let remark = [...string.matchAll(/\\begin{remark}(.+)\\end{remark}/gs)];
//         result.remark = remark[0][1].trim();
//     }
//     else {
//         // console.log({content: string})
//         // console.log(...string.matchAll(/[\r\n]{6,}/g))
//         result.text = string.replaceAll(/[\r\n]{4,}/g, "\n").split("\n").join("\n\n");
//     }
//     return result;
// }

// function cleanText(string, lang=null) {
//     let result = string;
//     if (lang == "KOM") {
//         result = result.replace("\\\\", "");
//         result = result.replaceAll(/\\(begin|end){[a-zA-Z]+}/g, "");
//     }
//     else {
//         result = result.split("\n").join("\n\n");
//     }
//     return result;
// }

async function setProposition(index) {
    document.getElementById("select-fig-"+index).selected = true;
    geometer.clear();
    await geometer.loadSource(sourceList[index]);
    // texts = await loadRawText(sourceList[index])
    for (let j=1; j<=2; j++) {
        insertTextToElement(
            document.getElementById(`page-content-col${j}-body`),
            textJson[index]
        )
        document.getElementById("select-lang"+j).onchange();
        // if (j == 1) break;
    }

    let selectStep = document.getElementById("select-step");
    for (let i=selectStep.childNodes.length; i>0; i--) {
        selectStep.childNodes[0].remove();
    }
    for (let i=geometer.stepMin; i<=geometer.stepMax; i++) {
        let option = document.createElement("option");
        option.value = i;
        option.textContent = i;
        option.setAttribute("id", "select-step-"+i);
        document.getElementById("select-step").appendChild(option);
        if (i==geometer.stepMin) {option.selected = true;}
    };
    // document.getElementById("check-original").checked = false;
    if (document.getElementById("check-original").checked) {
        geometer.toggleOriginal()
    }
}

import {Geometer} from "/static/geometer.js"

let sourceList = [
    "/static/on_spirals/prop01",
    "/static/on_spirals/prop02",
    "/static/on_spirals/prop03",
    "/static/on_spirals/prop04",
    "/static/on_spirals/prop05",
    "/static/on_spirals/prop06",
    "/static/on_spirals/prop07",
    "/static/on_spirals/prop08",
    "/static/on_spirals/prop09",
];
let langList = [
    "ELH", "KOC", "KOM"
];
let langDetailList = [
    "그리스어 원본", "우리말(고전학자)", "우리말(수학자)"
]

let geometer = new Geometer(document.getElementById("svg-wrapper"))
geometer.domElement.classList.add("boxed")
// let texts;
let textJson = await loadRawTextJson('/static/on_spirals/propositions.json');
// let textJson = [];
// for (let i=0; i<9; i++) {
//     textJson.push({
//         ELH: {paragraphs: []},
//         KOC: {paragraphs: []},
//         KOM: {paragraphs: []},
//     })
// }

// proposition navigation
document.getElementById("button-fig-prev").onclick = async function () {
    let i = +document.getElementById("select-fig").value;
    if (i <= 0) { return; }
    setProposition(i-1);
};
document.getElementById("button-fig-next").onclick = async function () {
    let i = +document.getElementById("select-fig").value;
    if (i >= sourceList.length-1) { return; }
    setProposition(i+1);
};
document.getElementById("select-fig").onchange = async function () {
    let i = +document.getElementById("select-fig").value;
    setProposition(i);
}
for (let i=0; i<sourceList.length; i++) {
    let option = document.createElement("option");
    option.value = i;
    option.textContent = sourceList[i];
    option.setAttribute("id", "select-fig-"+i);
    document.getElementById("select-fig").appendChild(option);
}
for (let j=1; j<=2; j++) {
    let selectProp = document.getElementById('select-fig');
    let selectLang = document.getElementById("select-lang"+j);
    for (let i=0; i<langList.length; i++) {
        let option = document.createElement("option");
        option.value = i;
        option.textContent = langDetailList[i];
        option.setAttribute("id", "select-lang" + j +"-"+i);
        selectLang.appendChild(option);
    }
    selectLang.onchange = function () {
        let i = selectLang.value;
        document.getElementById(`page-content-col${j}-body`)
            .querySelectorAll('.language-layer')
            .forEach(el => {el.style.opacity = 0; el.style.zIndex = -1; el.classList.add('unselectable');});
        document.getElementById(`page-content-col${j}-body`)
            .querySelectorAll(`.${langList[i]}`)
            .forEach(el => {el.style.opacity = 1; el.style.zIndex = 1; el.classList.remove('unselectable')});
        // document.getElementById(`page-content-col${j}-body`).innerHTML = (
        //     '<p>'
        //     + textJson[selectProp.value][langList[i]].paragraphs.join('</p><p>')
        //     +'</p>'
        // );
        document.getElementById(`page-content-col${j}-foot`).innerHTML = (
            '<p>'
            + textJson[selectProp.value][langList[i]].footnotes.join('</p><p>')
            +'</p>'
        )
        if (langList[i] == "KOM") {
            MathJax.typeset()
        }
    }
    document.getElementById(`page-content-col${j}-body`).onscroll = function () {
        for (let el of document.body.querySelectorAll('.text-col-body')) {
            el.scrollTop = this.scrollTop;
        }
    }
}


// diagram navigation
document.getElementById("button-back").onclick = function () {
    geometer.stepBack();
    document.getElementById("select-step-"+geometer.step).selected = true;
};
document.getElementById("button-forward").onclick = function () {
    geometer.stepForward();
    document.getElementById("select-step-"+geometer.step).selected = true;
};
document.getElementById("select-step").onchange = function () {
    for (let i=geometer.step; i<this.value; i++) {
        geometer.stepForward();
    }
    for (let i=geometer.step; i>this.value; i--) {
        geometer.stepBack();
    }
}
document.getElementById("check-original").onchange = function () {
    geometer.toggleOriginal();
    document.getElementById("button-back").disabled = !document.getElementById("button-back").disabled;
    document.getElementById("button-forward").disabled = !document.getElementById("button-forward").disabled;
    document.getElementById("select-step").disabled = !document.getElementById("select-step").disabled;
};


let idxInit = sourceList.length-1
document.getElementById("select-lang2-2").selected = true;
setProposition(idxInit);

// let html;
// await new Promise(function (resolve, reject) {
//     let xhr = new XMLHttpRequest();
//     xhr.open("GET", ".references/수학고전 번역모임_20240105 업로드_'나선에 관하여'_정리1.htm")
//     xhr.onload = function () {
//         if ((xhr.status >= 200) && (xhr.status < 400)) {
//             html = xhr.responseText;
//         }
//         else {
//             ;
//             // reject();
//         }
//         resolve();
//     }
//     xhr.send();
// })
// console.log(html);
</script>